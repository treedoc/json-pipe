#!/usr/bin/env node
import { CliSpec, CliParser, CliArgDeco, EnumValues, EnumsValueOf } from 'cli-arg-deco'
import { TD, TDJSONParser, TDJSONParserOption, TDJSONWriterOption, StringCharSource, TDEncodeOption, NodeFilter } from "Treedoc"
import 'process';
import * as fs from 'fs';
// import { pipeline } from 'stream/promises'
/* eslint-disable */
const { pipeline } = require('stream/promises');

const {Name, Description, Index, ShortName, Required, Examples, Decoder} = CliArgDeco;

enum FileType { JSON, LOG }

@Name("json-pipe") 
@Description(
  `Transform an stream of JSON objects or log entries by applying the filter and map expressions. 
  The expressions are written in Javascript. Current JSON object can be access as variable of '_'.`)
@Examples([
  "echo '{name: John, age: 10} {name: Alice, age: 30}' | json-pipe '{capitalName: _.name.toToUpperCase()}' -f '_.age<20' ",
  "cat sample/sample.json | json-pipe '`id: ${_.id}`'",
  "cat sample/sample.json | json-pipe '({id: _.id+1, firstName: _.first_name.toUpperCase()})'",
  "cat sample/sample.json | json-pipe -f '_.gender===\"Male\"'",
  "cat sample/sample.log | json-pipe -t LOG -f \"_.guid==='guid1'\"",
])
class CliArg {
  @Index(0) @Description("Query expression") @Required(false)
  map = '_';

  @ShortName("f") @Description("Filter expression. if true, it will be included in the output")
  filter = 'true';

  @ShortName("i") @Description("Input file instead of stdin")
  inputFile?: string;

  @ShortName("o") @Description("Out file instead of stdout")
  outputFile?: string;
  
  @ShortName("m") @Description("Import external modules. Modules could be a local file or URL")
  imports?: string;

  @ShortName("t") @Description(`The file type, could be [${EnumValues(FileType)}], default is JSON`, ) @Decoder(_ => EnumsValueOf(FileType, _))
  fileType = FileType.JSON;

  @ShortName("p") @Description("For log fileType. The regex pattern to match the first line for the event and generate an array of that.")
  logPattern = "(?<time>\\d{4}\\/\\d{2}\\/\\d{2} \\d{2}:\\d{2}:\\d{2}.\\d{3}) *(?<level>[^ ]*) *\\[(?<name>.*?)\\] *\\[(?<thread>.*?)\\] *\\[(?<app>.*?)\\] *\\[(?<guid>.*?)\\] *(?<message>.*)";

  @Description("For log fileType. The max line of a single event if input is a log file")
  maxLine = 10000;

  @Description("Strip the file name section if the file is generated by grep of multiple files")
  stripFileName = false;

  @Description("List of mask out fields in regular expression to match the fields path, e.g.  '.*/firstName,.*/lastName'")
  maskFields: string[] = [];

  @Description("If indentFactor is not 0, the json out will be pretty formatted with the indentFactor")
  indentFactor = 0;

  @ShortName("h") @Description("Show usage")
  help = false;
}

let m;

class JsonPipe {
  readonly input: NodeJS.ReadStream | fs.ReadStream;
  readonly output: NodeJS.WriteStream | fs.WriteStream;
  constructor(public readonly arg: CliArg) {
    this.input = this.arg.inputFile ? fs.createReadStream(this.arg.inputFile) : process.stdin;
    this.output = this.arg.outputFile ? fs.createWriteStream(this.arg.outputFile) : process.stdout;
  }

  async start() {
    const THIS = this;
    if (this.arg.fileType === FileType.JSON)
      await pipeline(
        this.input,
        this.parseJson.bind(THIS),  // Not sure why this is not bound for generator function
        this.output,
        // this.handleError,
      )
    else if (this.arg.fileType === FileType.LOG) {
      await pipeline(
        this.input,
        this.parseLines.bind(THIS),  // Not sure why this is not bound for generator function
        this.parseLog.bind(THIS),
        this.output,
        // this.handleError,
      )
    }
  }

  handleError(err: any) {
    if (err) {
      console.error('Pipeline failed.', err);
    } else {
      console.error('Pipeline succeeded.');
    }
  }

  async *parseJson(source: any) {
    source.setEncoding('utf8');
    let remain = '';
    for await (const chunk of source) {
      const src = new StringCharSource((remain + chunk).trim());
      let bookmark = src.getBookmark();
      while(src.skipSpacesAndReturnsAndCommas()) {
        try {
          // TODO: implement resumable partial parsing (Non-blocking parsing)
          const node = TDJSONParser.get().parse(src);
          bookmark = src.getBookmark();
          // console.log("node=" + node.toString());
          // console.log(JSON.stringify(node.toObject(false)));
          const obj = this.transformAndToString(node.toObject(false));
          if (obj) 
            yield obj;
        } catch (e) {
          console.error(e.name);
          console.error(e);
          break;
        } finally {
          remain = src.str.substring(bookmark.pos);
        }
      }
    }
  }

  // transfer chunks to lines
  async * parseLines(source: any) {
    source.setEncoding('utf8');
    let remain = '';
    for await (const chunk of source) {
      const src = new StringCharSource((remain + chunk));
      while(true) {
        const line = src.readUntilTerminator('\n\r');
        if (src.isEof()) {
          remain = line; 
          break;
        }
        src.skipChars('\n\r');
        if (line)
          yield line + "\n";
      }
    }
  }

  async * parseLog(source: any) {
    const regex = new RegExp(this.arg.logPattern);
    let logEntry: any = {additionalMessage: ''};
    let lines = 0;
    for await (let line of source) {
      if (this.arg.stripFileName) {
        const p = (line as string).indexOf(':');
        if (p >= 0)
          line = line.substr(p+1); 
      }
        
      const groups = regex.exec(line);
      if (groups != null || lines >= this.arg.maxLine) {
        const obj = this.transformAndToString(logEntry);
        if (obj)
          yield obj;
        logEntry = groups != null ? groups.groups : {};
        logEntry.additionalMessage = '';
        lines = 0;
      } else {
        logEntry.additionalMessage += line;
        lines ++;
      }
    }
    const o = this.transformAndToString(logEntry);
    if (o)
      yield o;
  }

  transformAndToString(_: any) {    
    /* tslint-disable */
    if (!eval(`${this.arg.filter}`))
      return undefined;

    const script = this.arg.map?.indexOf(" return ") > 0  // Wrapper with a function
      ? `(function(){${this.arg.map}})()` : `(${this.arg.map})`;

    /* tslint-disable */
    const obj = eval(script);
    return typeof(obj) === 'string' ? obj + "\n" : this.toJson(obj) + "\n";
  }

  toJson(obj: any) {
    const codeOpt = new TDEncodeOption().setJsonOption(
      new TDJSONWriterOption()
          .addNodeFilter(NodeFilter.mask(...this.arg.maskFields))
          .setIndentFactor(this.arg.indentFactor));
    return TD.stringify(obj, codeOpt)
  }
}

(async function main() {
  const spec = new CliSpec<CliArg>(CliArg);
  const parser = spec.parse(process.argv, 2);
  const cliArg = parser.target;
  console.error(`Parsed argument: ${JSON.stringify(cliArg)}`);
  if (parser.hasError()) {
    console.error(`Error parsing CLI parameters: ${parser.getErrorsAsString()}`);
    console.error(spec.printUsage());
    return -1;
  }
  if (cliArg.help) {
    console.error(spec.printUsage());
    return 0;
  }

  if (cliArg.imports) {
    m = require(cliArg.imports);
    console.log(m);
  }
  await new JsonPipe(cliArg).start();
})();

